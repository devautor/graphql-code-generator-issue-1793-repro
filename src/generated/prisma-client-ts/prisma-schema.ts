// Code generated by Prisma (prisma@1.32.0). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

export const typeDefs = /* GraphQL */ `type AddressCustomer {
  id: ID!
  customerAddress: Customer
  building: String!
  locality: String!
  city: String!
  postalCode: String!
  state: String!
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String!
  recipientMobile: String!
  recipientAlternateMobile: String
  addressType: AddressType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddressCustomerConnection {
  pageInfo: PageInfo!
  edges: [AddressCustomerEdge]!
  aggregate: AggregateAddressCustomer!
}

input AddressCustomerCreateInput {
  id: ID
  customerAddress: CustomerCreateOneWithoutAddressesInput
  building: String!
  locality: String!
  city: String!
  postalCode: String!
  state: String!
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String!
  recipientMobile: String!
  recipientAlternateMobile: String
  addressType: AddressType!
}

input AddressCustomerCreateManyWithoutCustomerAddressInput {
  create: [AddressCustomerCreateWithoutCustomerAddressInput!]
  connect: [AddressCustomerWhereUniqueInput!]
}

input AddressCustomerCreateWithoutCustomerAddressInput {
  id: ID
  building: String!
  locality: String!
  city: String!
  postalCode: String!
  state: String!
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String!
  recipientMobile: String!
  recipientAlternateMobile: String
  addressType: AddressType!
}

type AddressCustomerEdge {
  node: AddressCustomer!
  cursor: String!
}

enum AddressCustomerOrderByInput {
  id_ASC
  id_DESC
  building_ASC
  building_DESC
  locality_ASC
  locality_DESC
  city_ASC
  city_DESC
  postalCode_ASC
  postalCode_DESC
  state_ASC
  state_DESC
  landmark_ASC
  landmark_DESC
  latitude_ASC
  latitude_DESC
  longitude_ASC
  longitude_DESC
  recipientName_ASC
  recipientName_DESC
  recipientMobile_ASC
  recipientMobile_DESC
  recipientAlternateMobile_ASC
  recipientAlternateMobile_DESC
  addressType_ASC
  addressType_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type AddressCustomerPreviousValues {
  id: ID!
  building: String!
  locality: String!
  city: String!
  postalCode: String!
  state: String!
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String!
  recipientMobile: String!
  recipientAlternateMobile: String
  addressType: AddressType!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input AddressCustomerScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  building: String
  building_not: String
  building_in: [String!]
  building_not_in: [String!]
  building_lt: String
  building_lte: String
  building_gt: String
  building_gte: String
  building_contains: String
  building_not_contains: String
  building_starts_with: String
  building_not_starts_with: String
  building_ends_with: String
  building_not_ends_with: String
  locality: String
  locality_not: String
  locality_in: [String!]
  locality_not_in: [String!]
  locality_lt: String
  locality_lte: String
  locality_gt: String
  locality_gte: String
  locality_contains: String
  locality_not_contains: String
  locality_starts_with: String
  locality_not_starts_with: String
  locality_ends_with: String
  locality_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  landmark: String
  landmark_not: String
  landmark_in: [String!]
  landmark_not_in: [String!]
  landmark_lt: String
  landmark_lte: String
  landmark_gt: String
  landmark_gte: String
  landmark_contains: String
  landmark_not_contains: String
  landmark_starts_with: String
  landmark_not_starts_with: String
  landmark_ends_with: String
  landmark_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  recipientName: String
  recipientName_not: String
  recipientName_in: [String!]
  recipientName_not_in: [String!]
  recipientName_lt: String
  recipientName_lte: String
  recipientName_gt: String
  recipientName_gte: String
  recipientName_contains: String
  recipientName_not_contains: String
  recipientName_starts_with: String
  recipientName_not_starts_with: String
  recipientName_ends_with: String
  recipientName_not_ends_with: String
  recipientMobile: String
  recipientMobile_not: String
  recipientMobile_in: [String!]
  recipientMobile_not_in: [String!]
  recipientMobile_lt: String
  recipientMobile_lte: String
  recipientMobile_gt: String
  recipientMobile_gte: String
  recipientMobile_contains: String
  recipientMobile_not_contains: String
  recipientMobile_starts_with: String
  recipientMobile_not_starts_with: String
  recipientMobile_ends_with: String
  recipientMobile_not_ends_with: String
  recipientAlternateMobile: String
  recipientAlternateMobile_not: String
  recipientAlternateMobile_in: [String!]
  recipientAlternateMobile_not_in: [String!]
  recipientAlternateMobile_lt: String
  recipientAlternateMobile_lte: String
  recipientAlternateMobile_gt: String
  recipientAlternateMobile_gte: String
  recipientAlternateMobile_contains: String
  recipientAlternateMobile_not_contains: String
  recipientAlternateMobile_starts_with: String
  recipientAlternateMobile_not_starts_with: String
  recipientAlternateMobile_ends_with: String
  recipientAlternateMobile_not_ends_with: String
  addressType: AddressType
  addressType_not: AddressType
  addressType_in: [AddressType!]
  addressType_not_in: [AddressType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressCustomerScalarWhereInput!]
  OR: [AddressCustomerScalarWhereInput!]
  NOT: [AddressCustomerScalarWhereInput!]
}

type AddressCustomerSubscriptionPayload {
  mutation: MutationType!
  node: AddressCustomer
  updatedFields: [String!]
  previousValues: AddressCustomerPreviousValues
}

input AddressCustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: AddressCustomerWhereInput
  AND: [AddressCustomerSubscriptionWhereInput!]
  OR: [AddressCustomerSubscriptionWhereInput!]
  NOT: [AddressCustomerSubscriptionWhereInput!]
}

input AddressCustomerUpdateInput {
  customerAddress: CustomerUpdateOneWithoutAddressesInput
  building: String
  locality: String
  city: String
  postalCode: String
  state: String
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String
  recipientMobile: String
  recipientAlternateMobile: String
  addressType: AddressType
}

input AddressCustomerUpdateManyDataInput {
  building: String
  locality: String
  city: String
  postalCode: String
  state: String
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String
  recipientMobile: String
  recipientAlternateMobile: String
  addressType: AddressType
}

input AddressCustomerUpdateManyMutationInput {
  building: String
  locality: String
  city: String
  postalCode: String
  state: String
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String
  recipientMobile: String
  recipientAlternateMobile: String
  addressType: AddressType
}

input AddressCustomerUpdateManyWithoutCustomerAddressInput {
  create: [AddressCustomerCreateWithoutCustomerAddressInput!]
  delete: [AddressCustomerWhereUniqueInput!]
  connect: [AddressCustomerWhereUniqueInput!]
  set: [AddressCustomerWhereUniqueInput!]
  disconnect: [AddressCustomerWhereUniqueInput!]
  update: [AddressCustomerUpdateWithWhereUniqueWithoutCustomerAddressInput!]
  upsert: [AddressCustomerUpsertWithWhereUniqueWithoutCustomerAddressInput!]
  deleteMany: [AddressCustomerScalarWhereInput!]
  updateMany: [AddressCustomerUpdateManyWithWhereNestedInput!]
}

input AddressCustomerUpdateManyWithWhereNestedInput {
  where: AddressCustomerScalarWhereInput!
  data: AddressCustomerUpdateManyDataInput!
}

input AddressCustomerUpdateWithoutCustomerAddressDataInput {
  building: String
  locality: String
  city: String
  postalCode: String
  state: String
  landmark: String
  latitude: Float
  longitude: Float
  recipientName: String
  recipientMobile: String
  recipientAlternateMobile: String
  addressType: AddressType
}

input AddressCustomerUpdateWithWhereUniqueWithoutCustomerAddressInput {
  where: AddressCustomerWhereUniqueInput!
  data: AddressCustomerUpdateWithoutCustomerAddressDataInput!
}

input AddressCustomerUpsertWithWhereUniqueWithoutCustomerAddressInput {
  where: AddressCustomerWhereUniqueInput!
  update: AddressCustomerUpdateWithoutCustomerAddressDataInput!
  create: AddressCustomerCreateWithoutCustomerAddressInput!
}

input AddressCustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customerAddress: CustomerWhereInput
  building: String
  building_not: String
  building_in: [String!]
  building_not_in: [String!]
  building_lt: String
  building_lte: String
  building_gt: String
  building_gte: String
  building_contains: String
  building_not_contains: String
  building_starts_with: String
  building_not_starts_with: String
  building_ends_with: String
  building_not_ends_with: String
  locality: String
  locality_not: String
  locality_in: [String!]
  locality_not_in: [String!]
  locality_lt: String
  locality_lte: String
  locality_gt: String
  locality_gte: String
  locality_contains: String
  locality_not_contains: String
  locality_starts_with: String
  locality_not_starts_with: String
  locality_ends_with: String
  locality_not_ends_with: String
  city: String
  city_not: String
  city_in: [String!]
  city_not_in: [String!]
  city_lt: String
  city_lte: String
  city_gt: String
  city_gte: String
  city_contains: String
  city_not_contains: String
  city_starts_with: String
  city_not_starts_with: String
  city_ends_with: String
  city_not_ends_with: String
  postalCode: String
  postalCode_not: String
  postalCode_in: [String!]
  postalCode_not_in: [String!]
  postalCode_lt: String
  postalCode_lte: String
  postalCode_gt: String
  postalCode_gte: String
  postalCode_contains: String
  postalCode_not_contains: String
  postalCode_starts_with: String
  postalCode_not_starts_with: String
  postalCode_ends_with: String
  postalCode_not_ends_with: String
  state: String
  state_not: String
  state_in: [String!]
  state_not_in: [String!]
  state_lt: String
  state_lte: String
  state_gt: String
  state_gte: String
  state_contains: String
  state_not_contains: String
  state_starts_with: String
  state_not_starts_with: String
  state_ends_with: String
  state_not_ends_with: String
  landmark: String
  landmark_not: String
  landmark_in: [String!]
  landmark_not_in: [String!]
  landmark_lt: String
  landmark_lte: String
  landmark_gt: String
  landmark_gte: String
  landmark_contains: String
  landmark_not_contains: String
  landmark_starts_with: String
  landmark_not_starts_with: String
  landmark_ends_with: String
  landmark_not_ends_with: String
  latitude: Float
  latitude_not: Float
  latitude_in: [Float!]
  latitude_not_in: [Float!]
  latitude_lt: Float
  latitude_lte: Float
  latitude_gt: Float
  latitude_gte: Float
  longitude: Float
  longitude_not: Float
  longitude_in: [Float!]
  longitude_not_in: [Float!]
  longitude_lt: Float
  longitude_lte: Float
  longitude_gt: Float
  longitude_gte: Float
  recipientName: String
  recipientName_not: String
  recipientName_in: [String!]
  recipientName_not_in: [String!]
  recipientName_lt: String
  recipientName_lte: String
  recipientName_gt: String
  recipientName_gte: String
  recipientName_contains: String
  recipientName_not_contains: String
  recipientName_starts_with: String
  recipientName_not_starts_with: String
  recipientName_ends_with: String
  recipientName_not_ends_with: String
  recipientMobile: String
  recipientMobile_not: String
  recipientMobile_in: [String!]
  recipientMobile_not_in: [String!]
  recipientMobile_lt: String
  recipientMobile_lte: String
  recipientMobile_gt: String
  recipientMobile_gte: String
  recipientMobile_contains: String
  recipientMobile_not_contains: String
  recipientMobile_starts_with: String
  recipientMobile_not_starts_with: String
  recipientMobile_ends_with: String
  recipientMobile_not_ends_with: String
  recipientAlternateMobile: String
  recipientAlternateMobile_not: String
  recipientAlternateMobile_in: [String!]
  recipientAlternateMobile_not_in: [String!]
  recipientAlternateMobile_lt: String
  recipientAlternateMobile_lte: String
  recipientAlternateMobile_gt: String
  recipientAlternateMobile_gte: String
  recipientAlternateMobile_contains: String
  recipientAlternateMobile_not_contains: String
  recipientAlternateMobile_starts_with: String
  recipientAlternateMobile_not_starts_with: String
  recipientAlternateMobile_ends_with: String
  recipientAlternateMobile_not_ends_with: String
  addressType: AddressType
  addressType_not: AddressType
  addressType_in: [AddressType!]
  addressType_not_in: [AddressType!]
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [AddressCustomerWhereInput!]
  OR: [AddressCustomerWhereInput!]
  NOT: [AddressCustomerWhereInput!]
}

input AddressCustomerWhereUniqueInput {
  id: ID
}

enum AddressType {
  HOME
  WORK
  OTHER
}

type AggregateAddressCustomer {
  count: Int!
}

type AggregateCustomer {
  count: Int!
}

type AggregateCustomerWishlist {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductVariant {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Customer {
  id: ID!
  emailId: String!
  mobileNumber: String
  name: String
  gender: Gender
  addresses(where: AddressCustomerWhereInput, orderBy: AddressCustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AddressCustomer!]
  wishlists(where: CustomerWishlistWhereInput, orderBy: CustomerWishlistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerWishlist!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerConnection {
  pageInfo: PageInfo!
  edges: [CustomerEdge]!
  aggregate: AggregateCustomer!
}

input CustomerCreateInput {
  id: ID
  emailId: String!
  mobileNumber: String
  name: String
  gender: Gender
  addresses: AddressCustomerCreateManyWithoutCustomerAddressInput
  wishlists: CustomerWishlistCreateManyWithoutCustomerInput
}

input CustomerCreateOneWithoutAddressesInput {
  create: CustomerCreateWithoutAddressesInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateOneWithoutWishlistsInput {
  create: CustomerCreateWithoutWishlistsInput
  connect: CustomerWhereUniqueInput
}

input CustomerCreateWithoutAddressesInput {
  id: ID
  emailId: String!
  mobileNumber: String
  name: String
  gender: Gender
  wishlists: CustomerWishlistCreateManyWithoutCustomerInput
}

input CustomerCreateWithoutWishlistsInput {
  id: ID
  emailId: String!
  mobileNumber: String
  name: String
  gender: Gender
  addresses: AddressCustomerCreateManyWithoutCustomerAddressInput
}

type CustomerEdge {
  node: Customer!
  cursor: String!
}

enum CustomerOrderByInput {
  id_ASC
  id_DESC
  emailId_ASC
  emailId_DESC
  mobileNumber_ASC
  mobileNumber_DESC
  name_ASC
  name_DESC
  gender_ASC
  gender_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerPreviousValues {
  id: ID!
  emailId: String!
  mobileNumber: String
  name: String
  gender: Gender
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerSubscriptionPayload {
  mutation: MutationType!
  node: Customer
  updatedFields: [String!]
  previousValues: CustomerPreviousValues
}

input CustomerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWhereInput
  AND: [CustomerSubscriptionWhereInput!]
  OR: [CustomerSubscriptionWhereInput!]
  NOT: [CustomerSubscriptionWhereInput!]
}

input CustomerUpdateInput {
  emailId: String
  mobileNumber: String
  name: String
  gender: Gender
  addresses: AddressCustomerUpdateManyWithoutCustomerAddressInput
  wishlists: CustomerWishlistUpdateManyWithoutCustomerInput
}

input CustomerUpdateManyMutationInput {
  emailId: String
  mobileNumber: String
  name: String
  gender: Gender
}

input CustomerUpdateOneRequiredWithoutWishlistsInput {
  create: CustomerCreateWithoutWishlistsInput
  update: CustomerUpdateWithoutWishlistsDataInput
  upsert: CustomerUpsertWithoutWishlistsInput
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateOneWithoutAddressesInput {
  create: CustomerCreateWithoutAddressesInput
  update: CustomerUpdateWithoutAddressesDataInput
  upsert: CustomerUpsertWithoutAddressesInput
  delete: Boolean
  disconnect: Boolean
  connect: CustomerWhereUniqueInput
}

input CustomerUpdateWithoutAddressesDataInput {
  emailId: String
  mobileNumber: String
  name: String
  gender: Gender
  wishlists: CustomerWishlistUpdateManyWithoutCustomerInput
}

input CustomerUpdateWithoutWishlistsDataInput {
  emailId: String
  mobileNumber: String
  name: String
  gender: Gender
  addresses: AddressCustomerUpdateManyWithoutCustomerAddressInput
}

input CustomerUpsertWithoutAddressesInput {
  update: CustomerUpdateWithoutAddressesDataInput!
  create: CustomerCreateWithoutAddressesInput!
}

input CustomerUpsertWithoutWishlistsInput {
  update: CustomerUpdateWithoutWishlistsDataInput!
  create: CustomerCreateWithoutWishlistsInput!
}

input CustomerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  emailId: String
  emailId_not: String
  emailId_in: [String!]
  emailId_not_in: [String!]
  emailId_lt: String
  emailId_lte: String
  emailId_gt: String
  emailId_gte: String
  emailId_contains: String
  emailId_not_contains: String
  emailId_starts_with: String
  emailId_not_starts_with: String
  emailId_ends_with: String
  emailId_not_ends_with: String
  mobileNumber: String
  mobileNumber_not: String
  mobileNumber_in: [String!]
  mobileNumber_not_in: [String!]
  mobileNumber_lt: String
  mobileNumber_lte: String
  mobileNumber_gt: String
  mobileNumber_gte: String
  mobileNumber_contains: String
  mobileNumber_not_contains: String
  mobileNumber_starts_with: String
  mobileNumber_not_starts_with: String
  mobileNumber_ends_with: String
  mobileNumber_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  gender: Gender
  gender_not: Gender
  gender_in: [Gender!]
  gender_not_in: [Gender!]
  addresses_every: AddressCustomerWhereInput
  addresses_some: AddressCustomerWhereInput
  addresses_none: AddressCustomerWhereInput
  wishlists_every: CustomerWishlistWhereInput
  wishlists_some: CustomerWishlistWhereInput
  wishlists_none: CustomerWishlistWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerWhereInput!]
  OR: [CustomerWhereInput!]
  NOT: [CustomerWhereInput!]
}

input CustomerWhereUniqueInput {
  id: ID
  emailId: String
}

type CustomerWishlist {
  id: ID!
  customer: Customer!
  listName: String!
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CustomerWishlistConnection {
  pageInfo: PageInfo!
  edges: [CustomerWishlistEdge]!
  aggregate: AggregateCustomerWishlist!
}

input CustomerWishlistCreateInput {
  id: ID
  customer: CustomerCreateOneWithoutWishlistsInput!
  listName: String!
  productVariants: ProductVariantCreateManyWithoutWishlistedInInput
}

input CustomerWishlistCreateManyWithoutCustomerInput {
  create: [CustomerWishlistCreateWithoutCustomerInput!]
  connect: [CustomerWishlistWhereUniqueInput!]
}

input CustomerWishlistCreateManyWithoutProductVariantsInput {
  create: [CustomerWishlistCreateWithoutProductVariantsInput!]
  connect: [CustomerWishlistWhereUniqueInput!]
}

input CustomerWishlistCreateWithoutCustomerInput {
  id: ID
  listName: String!
  productVariants: ProductVariantCreateManyWithoutWishlistedInInput
}

input CustomerWishlistCreateWithoutProductVariantsInput {
  id: ID
  customer: CustomerCreateOneWithoutWishlistsInput!
  listName: String!
}

type CustomerWishlistEdge {
  node: CustomerWishlist!
  cursor: String!
}

enum CustomerWishlistOrderByInput {
  id_ASC
  id_DESC
  listName_ASC
  listName_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CustomerWishlistPreviousValues {
  id: ID!
  listName: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input CustomerWishlistScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  listName: String
  listName_not: String
  listName_in: [String!]
  listName_not_in: [String!]
  listName_lt: String
  listName_lte: String
  listName_gt: String
  listName_gte: String
  listName_contains: String
  listName_not_contains: String
  listName_starts_with: String
  listName_not_starts_with: String
  listName_ends_with: String
  listName_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerWishlistScalarWhereInput!]
  OR: [CustomerWishlistScalarWhereInput!]
  NOT: [CustomerWishlistScalarWhereInput!]
}

type CustomerWishlistSubscriptionPayload {
  mutation: MutationType!
  node: CustomerWishlist
  updatedFields: [String!]
  previousValues: CustomerWishlistPreviousValues
}

input CustomerWishlistSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CustomerWishlistWhereInput
  AND: [CustomerWishlistSubscriptionWhereInput!]
  OR: [CustomerWishlistSubscriptionWhereInput!]
  NOT: [CustomerWishlistSubscriptionWhereInput!]
}

input CustomerWishlistUpdateInput {
  customer: CustomerUpdateOneRequiredWithoutWishlistsInput
  listName: String
  productVariants: ProductVariantUpdateManyWithoutWishlistedInInput
}

input CustomerWishlistUpdateManyDataInput {
  listName: String
}

input CustomerWishlistUpdateManyMutationInput {
  listName: String
}

input CustomerWishlistUpdateManyWithoutCustomerInput {
  create: [CustomerWishlistCreateWithoutCustomerInput!]
  delete: [CustomerWishlistWhereUniqueInput!]
  connect: [CustomerWishlistWhereUniqueInput!]
  set: [CustomerWishlistWhereUniqueInput!]
  disconnect: [CustomerWishlistWhereUniqueInput!]
  update: [CustomerWishlistUpdateWithWhereUniqueWithoutCustomerInput!]
  upsert: [CustomerWishlistUpsertWithWhereUniqueWithoutCustomerInput!]
  deleteMany: [CustomerWishlistScalarWhereInput!]
  updateMany: [CustomerWishlistUpdateManyWithWhereNestedInput!]
}

input CustomerWishlistUpdateManyWithoutProductVariantsInput {
  create: [CustomerWishlistCreateWithoutProductVariantsInput!]
  delete: [CustomerWishlistWhereUniqueInput!]
  connect: [CustomerWishlistWhereUniqueInput!]
  set: [CustomerWishlistWhereUniqueInput!]
  disconnect: [CustomerWishlistWhereUniqueInput!]
  update: [CustomerWishlistUpdateWithWhereUniqueWithoutProductVariantsInput!]
  upsert: [CustomerWishlistUpsertWithWhereUniqueWithoutProductVariantsInput!]
  deleteMany: [CustomerWishlistScalarWhereInput!]
  updateMany: [CustomerWishlistUpdateManyWithWhereNestedInput!]
}

input CustomerWishlistUpdateManyWithWhereNestedInput {
  where: CustomerWishlistScalarWhereInput!
  data: CustomerWishlistUpdateManyDataInput!
}

input CustomerWishlistUpdateWithoutCustomerDataInput {
  listName: String
  productVariants: ProductVariantUpdateManyWithoutWishlistedInInput
}

input CustomerWishlistUpdateWithoutProductVariantsDataInput {
  customer: CustomerUpdateOneRequiredWithoutWishlistsInput
  listName: String
}

input CustomerWishlistUpdateWithWhereUniqueWithoutCustomerInput {
  where: CustomerWishlistWhereUniqueInput!
  data: CustomerWishlistUpdateWithoutCustomerDataInput!
}

input CustomerWishlistUpdateWithWhereUniqueWithoutProductVariantsInput {
  where: CustomerWishlistWhereUniqueInput!
  data: CustomerWishlistUpdateWithoutProductVariantsDataInput!
}

input CustomerWishlistUpsertWithWhereUniqueWithoutCustomerInput {
  where: CustomerWishlistWhereUniqueInput!
  update: CustomerWishlistUpdateWithoutCustomerDataInput!
  create: CustomerWishlistCreateWithoutCustomerInput!
}

input CustomerWishlistUpsertWithWhereUniqueWithoutProductVariantsInput {
  where: CustomerWishlistWhereUniqueInput!
  update: CustomerWishlistUpdateWithoutProductVariantsDataInput!
  create: CustomerWishlistCreateWithoutProductVariantsInput!
}

input CustomerWishlistWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  customer: CustomerWhereInput
  listName: String
  listName_not: String
  listName_in: [String!]
  listName_not_in: [String!]
  listName_lt: String
  listName_lte: String
  listName_gt: String
  listName_gte: String
  listName_contains: String
  listName_not_contains: String
  listName_starts_with: String
  listName_not_starts_with: String
  listName_ends_with: String
  listName_not_ends_with: String
  productVariants_every: ProductVariantWhereInput
  productVariants_some: ProductVariantWhereInput
  productVariants_none: ProductVariantWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [CustomerWishlistWhereInput!]
  OR: [CustomerWishlistWhereInput!]
  NOT: [CustomerWishlistWhereInput!]
}

input CustomerWishlistWhereUniqueInput {
  id: ID
}

scalar DateTime

enum Gender {
  MALE
  FEMALE
  OTHER
}

scalar Long

type Mutation {
  createAddressCustomer(data: AddressCustomerCreateInput!): AddressCustomer!
  updateAddressCustomer(data: AddressCustomerUpdateInput!, where: AddressCustomerWhereUniqueInput!): AddressCustomer
  updateManyAddressCustomers(data: AddressCustomerUpdateManyMutationInput!, where: AddressCustomerWhereInput): BatchPayload!
  upsertAddressCustomer(where: AddressCustomerWhereUniqueInput!, create: AddressCustomerCreateInput!, update: AddressCustomerUpdateInput!): AddressCustomer!
  deleteAddressCustomer(where: AddressCustomerWhereUniqueInput!): AddressCustomer
  deleteManyAddressCustomers(where: AddressCustomerWhereInput): BatchPayload!
  createCustomer(data: CustomerCreateInput!): Customer!
  updateCustomer(data: CustomerUpdateInput!, where: CustomerWhereUniqueInput!): Customer
  updateManyCustomers(data: CustomerUpdateManyMutationInput!, where: CustomerWhereInput): BatchPayload!
  upsertCustomer(where: CustomerWhereUniqueInput!, create: CustomerCreateInput!, update: CustomerUpdateInput!): Customer!
  deleteCustomer(where: CustomerWhereUniqueInput!): Customer
  deleteManyCustomers(where: CustomerWhereInput): BatchPayload!
  createCustomerWishlist(data: CustomerWishlistCreateInput!): CustomerWishlist!
  updateCustomerWishlist(data: CustomerWishlistUpdateInput!, where: CustomerWishlistWhereUniqueInput!): CustomerWishlist
  updateManyCustomerWishlists(data: CustomerWishlistUpdateManyMutationInput!, where: CustomerWishlistWhereInput): BatchPayload!
  upsertCustomerWishlist(where: CustomerWishlistWhereUniqueInput!, create: CustomerWishlistCreateInput!, update: CustomerWishlistUpdateInput!): CustomerWishlist!
  deleteCustomerWishlist(where: CustomerWishlistWhereUniqueInput!): CustomerWishlist
  deleteManyCustomerWishlists(where: CustomerWishlistWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductVariant(data: ProductVariantCreateInput!): ProductVariant!
  updateProductVariant(data: ProductVariantUpdateInput!, where: ProductVariantWhereUniqueInput!): ProductVariant
  updateManyProductVariants(data: ProductVariantUpdateManyMutationInput!, where: ProductVariantWhereInput): BatchPayload!
  upsertProductVariant(where: ProductVariantWhereUniqueInput!, create: ProductVariantCreateInput!, update: ProductVariantUpdateInput!): ProductVariant!
  deleteProductVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  deleteManyProductVariants(where: ProductVariantWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Product {
  id: ID!
  isPublished: Boolean!
  name: String!
  description: String!
  brand: String!
  manufacturer: String
  tags: [String!]!
  tax: Float!
  variants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  isPublished: Boolean
  name: String!
  description: String!
  brand: String!
  manufacturer: String
  tags: ProductCreatetagsInput
  tax: Float!
  variants: ProductVariantCreateManyWithoutProductInput
}

input ProductCreateOneWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  connect: ProductWhereUniqueInput
}

input ProductCreatetagsInput {
  set: [String!]
}

input ProductCreateWithoutVariantsInput {
  id: ID
  isPublished: Boolean
  name: String!
  description: String!
  brand: String!
  manufacturer: String
  tags: ProductCreatetagsInput
  tax: Float!
}

type ProductEdge {
  node: Product!
  cursor: String!
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  isPublished_ASC
  isPublished_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  brand_ASC
  brand_DESC
  manufacturer_ASC
  manufacturer_DESC
  tax_ASC
  tax_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductPreviousValues {
  id: ID!
  isPublished: Boolean!
  name: String!
  description: String!
  brand: String!
  manufacturer: String
  tags: [String!]!
  tax: Float!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateInput {
  isPublished: Boolean
  name: String
  description: String
  brand: String
  manufacturer: String
  tags: ProductUpdatetagsInput
  tax: Float
  variants: ProductVariantUpdateManyWithoutProductInput
}

input ProductUpdateManyMutationInput {
  isPublished: Boolean
  name: String
  description: String
  brand: String
  manufacturer: String
  tags: ProductUpdatetagsInput
  tax: Float
}

input ProductUpdateOneRequiredWithoutVariantsInput {
  create: ProductCreateWithoutVariantsInput
  update: ProductUpdateWithoutVariantsDataInput
  upsert: ProductUpsertWithoutVariantsInput
  connect: ProductWhereUniqueInput
}

input ProductUpdatetagsInput {
  set: [String!]
}

input ProductUpdateWithoutVariantsDataInput {
  isPublished: Boolean
  name: String
  description: String
  brand: String
  manufacturer: String
  tags: ProductUpdatetagsInput
  tax: Float
}

input ProductUpsertWithoutVariantsInput {
  update: ProductUpdateWithoutVariantsDataInput!
  create: ProductCreateWithoutVariantsInput!
}

type ProductVariant {
  id: ID!
  product: Product!
  universalIdType: UniversalIdType
  universalId: String
  skuId: String!
  inStock: Boolean!
  listPrice: Int!
  salePrice: Int!
  wishlistedIn(where: CustomerWishlistWhereInput, orderBy: CustomerWishlistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerWishlist!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ProductVariantConnection {
  pageInfo: PageInfo!
  edges: [ProductVariantEdge]!
  aggregate: AggregateProductVariant!
}

input ProductVariantCreateInput {
  id: ID
  product: ProductCreateOneWithoutVariantsInput!
  universalIdType: UniversalIdType
  universalId: String
  skuId: String!
  inStock: Boolean
  listPrice: Int!
  salePrice: Int!
  wishlistedIn: CustomerWishlistCreateManyWithoutProductVariantsInput
}

input ProductVariantCreateManyWithoutProductInput {
  create: [ProductVariantCreateWithoutProductInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateManyWithoutWishlistedInInput {
  create: [ProductVariantCreateWithoutWishlistedInInput!]
  connect: [ProductVariantWhereUniqueInput!]
}

input ProductVariantCreateWithoutProductInput {
  id: ID
  universalIdType: UniversalIdType
  universalId: String
  skuId: String!
  inStock: Boolean
  listPrice: Int!
  salePrice: Int!
  wishlistedIn: CustomerWishlistCreateManyWithoutProductVariantsInput
}

input ProductVariantCreateWithoutWishlistedInInput {
  id: ID
  product: ProductCreateOneWithoutVariantsInput!
  universalIdType: UniversalIdType
  universalId: String
  skuId: String!
  inStock: Boolean
  listPrice: Int!
  salePrice: Int!
}

type ProductVariantEdge {
  node: ProductVariant!
  cursor: String!
}

enum ProductVariantOrderByInput {
  id_ASC
  id_DESC
  universalIdType_ASC
  universalIdType_DESC
  universalId_ASC
  universalId_DESC
  skuId_ASC
  skuId_DESC
  inStock_ASC
  inStock_DESC
  listPrice_ASC
  listPrice_DESC
  salePrice_ASC
  salePrice_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ProductVariantPreviousValues {
  id: ID!
  universalIdType: UniversalIdType
  universalId: String
  skuId: String!
  inStock: Boolean!
  listPrice: Int!
  salePrice: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input ProductVariantScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  universalIdType: UniversalIdType
  universalIdType_not: UniversalIdType
  universalIdType_in: [UniversalIdType!]
  universalIdType_not_in: [UniversalIdType!]
  universalId: String
  universalId_not: String
  universalId_in: [String!]
  universalId_not_in: [String!]
  universalId_lt: String
  universalId_lte: String
  universalId_gt: String
  universalId_gte: String
  universalId_contains: String
  universalId_not_contains: String
  universalId_starts_with: String
  universalId_not_starts_with: String
  universalId_ends_with: String
  universalId_not_ends_with: String
  skuId: String
  skuId_not: String
  skuId_in: [String!]
  skuId_not_in: [String!]
  skuId_lt: String
  skuId_lte: String
  skuId_gt: String
  skuId_gte: String
  skuId_contains: String
  skuId_not_contains: String
  skuId_starts_with: String
  skuId_not_starts_with: String
  skuId_ends_with: String
  skuId_not_ends_with: String
  inStock: Boolean
  inStock_not: Boolean
  listPrice: Int
  listPrice_not: Int
  listPrice_in: [Int!]
  listPrice_not_in: [Int!]
  listPrice_lt: Int
  listPrice_lte: Int
  listPrice_gt: Int
  listPrice_gte: Int
  salePrice: Int
  salePrice_not: Int
  salePrice_in: [Int!]
  salePrice_not_in: [Int!]
  salePrice_lt: Int
  salePrice_lte: Int
  salePrice_gt: Int
  salePrice_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantScalarWhereInput!]
  OR: [ProductVariantScalarWhereInput!]
  NOT: [ProductVariantScalarWhereInput!]
}

type ProductVariantSubscriptionPayload {
  mutation: MutationType!
  node: ProductVariant
  updatedFields: [String!]
  previousValues: ProductVariantPreviousValues
}

input ProductVariantSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductVariantWhereInput
  AND: [ProductVariantSubscriptionWhereInput!]
  OR: [ProductVariantSubscriptionWhereInput!]
  NOT: [ProductVariantSubscriptionWhereInput!]
}

input ProductVariantUpdateInput {
  product: ProductUpdateOneRequiredWithoutVariantsInput
  universalIdType: UniversalIdType
  universalId: String
  skuId: String
  inStock: Boolean
  listPrice: Int
  salePrice: Int
  wishlistedIn: CustomerWishlistUpdateManyWithoutProductVariantsInput
}

input ProductVariantUpdateManyDataInput {
  universalIdType: UniversalIdType
  universalId: String
  skuId: String
  inStock: Boolean
  listPrice: Int
  salePrice: Int
}

input ProductVariantUpdateManyMutationInput {
  universalIdType: UniversalIdType
  universalId: String
  skuId: String
  inStock: Boolean
  listPrice: Int
  salePrice: Int
}

input ProductVariantUpdateManyWithoutProductInput {
  create: [ProductVariantCreateWithoutProductInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutProductInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutProductInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithoutWishlistedInInput {
  create: [ProductVariantCreateWithoutWishlistedInInput!]
  delete: [ProductVariantWhereUniqueInput!]
  connect: [ProductVariantWhereUniqueInput!]
  set: [ProductVariantWhereUniqueInput!]
  disconnect: [ProductVariantWhereUniqueInput!]
  update: [ProductVariantUpdateWithWhereUniqueWithoutWishlistedInInput!]
  upsert: [ProductVariantUpsertWithWhereUniqueWithoutWishlistedInInput!]
  deleteMany: [ProductVariantScalarWhereInput!]
  updateMany: [ProductVariantUpdateManyWithWhereNestedInput!]
}

input ProductVariantUpdateManyWithWhereNestedInput {
  where: ProductVariantScalarWhereInput!
  data: ProductVariantUpdateManyDataInput!
}

input ProductVariantUpdateWithoutProductDataInput {
  universalIdType: UniversalIdType
  universalId: String
  skuId: String
  inStock: Boolean
  listPrice: Int
  salePrice: Int
  wishlistedIn: CustomerWishlistUpdateManyWithoutProductVariantsInput
}

input ProductVariantUpdateWithoutWishlistedInDataInput {
  product: ProductUpdateOneRequiredWithoutVariantsInput
  universalIdType: UniversalIdType
  universalId: String
  skuId: String
  inStock: Boolean
  listPrice: Int
  salePrice: Int
}

input ProductVariantUpdateWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutProductDataInput!
}

input ProductVariantUpdateWithWhereUniqueWithoutWishlistedInInput {
  where: ProductVariantWhereUniqueInput!
  data: ProductVariantUpdateWithoutWishlistedInDataInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutProductInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutProductDataInput!
  create: ProductVariantCreateWithoutProductInput!
}

input ProductVariantUpsertWithWhereUniqueWithoutWishlistedInInput {
  where: ProductVariantWhereUniqueInput!
  update: ProductVariantUpdateWithoutWishlistedInDataInput!
  create: ProductVariantCreateWithoutWishlistedInInput!
}

input ProductVariantWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  universalIdType: UniversalIdType
  universalIdType_not: UniversalIdType
  universalIdType_in: [UniversalIdType!]
  universalIdType_not_in: [UniversalIdType!]
  universalId: String
  universalId_not: String
  universalId_in: [String!]
  universalId_not_in: [String!]
  universalId_lt: String
  universalId_lte: String
  universalId_gt: String
  universalId_gte: String
  universalId_contains: String
  universalId_not_contains: String
  universalId_starts_with: String
  universalId_not_starts_with: String
  universalId_ends_with: String
  universalId_not_ends_with: String
  skuId: String
  skuId_not: String
  skuId_in: [String!]
  skuId_not_in: [String!]
  skuId_lt: String
  skuId_lte: String
  skuId_gt: String
  skuId_gte: String
  skuId_contains: String
  skuId_not_contains: String
  skuId_starts_with: String
  skuId_not_starts_with: String
  skuId_ends_with: String
  skuId_not_ends_with: String
  inStock: Boolean
  inStock_not: Boolean
  listPrice: Int
  listPrice_not: Int
  listPrice_in: [Int!]
  listPrice_not_in: [Int!]
  listPrice_lt: Int
  listPrice_lte: Int
  listPrice_gt: Int
  listPrice_gte: Int
  salePrice: Int
  salePrice_not: Int
  salePrice_in: [Int!]
  salePrice_not_in: [Int!]
  salePrice_lt: Int
  salePrice_lte: Int
  salePrice_gt: Int
  salePrice_gte: Int
  wishlistedIn_every: CustomerWishlistWhereInput
  wishlistedIn_some: CustomerWishlistWhereInput
  wishlistedIn_none: CustomerWishlistWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductVariantWhereInput!]
  OR: [ProductVariantWhereInput!]
  NOT: [ProductVariantWhereInput!]
}

input ProductVariantWhereUniqueInput {
  id: ID
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  isPublished: Boolean
  isPublished_not: Boolean
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  brand: String
  brand_not: String
  brand_in: [String!]
  brand_not_in: [String!]
  brand_lt: String
  brand_lte: String
  brand_gt: String
  brand_gte: String
  brand_contains: String
  brand_not_contains: String
  brand_starts_with: String
  brand_not_starts_with: String
  brand_ends_with: String
  brand_not_ends_with: String
  manufacturer: String
  manufacturer_not: String
  manufacturer_in: [String!]
  manufacturer_not_in: [String!]
  manufacturer_lt: String
  manufacturer_lte: String
  manufacturer_gt: String
  manufacturer_gte: String
  manufacturer_contains: String
  manufacturer_not_contains: String
  manufacturer_starts_with: String
  manufacturer_not_starts_with: String
  manufacturer_ends_with: String
  manufacturer_not_ends_with: String
  tax: Float
  tax_not: Float
  tax_in: [Float!]
  tax_not_in: [Float!]
  tax_lt: Float
  tax_lte: Float
  tax_gt: Float
  tax_gte: Float
  variants_every: ProductVariantWhereInput
  variants_some: ProductVariantWhereInput
  variants_none: ProductVariantWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  addressCustomer(where: AddressCustomerWhereUniqueInput!): AddressCustomer
  addressCustomers(where: AddressCustomerWhereInput, orderBy: AddressCustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [AddressCustomer]!
  addressCustomersConnection(where: AddressCustomerWhereInput, orderBy: AddressCustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): AddressCustomerConnection!
  customer(where: CustomerWhereUniqueInput!): Customer
  customers(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Customer]!
  customersConnection(where: CustomerWhereInput, orderBy: CustomerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerConnection!
  customerWishlist(where: CustomerWishlistWhereUniqueInput!): CustomerWishlist
  customerWishlists(where: CustomerWishlistWhereInput, orderBy: CustomerWishlistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CustomerWishlist]!
  customerWishlistsConnection(where: CustomerWishlistWhereInput, orderBy: CustomerWishlistOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CustomerWishlistConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productVariant(where: ProductVariantWhereUniqueInput!): ProductVariant
  productVariants(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductVariant]!
  productVariantsConnection(where: ProductVariantWhereInput, orderBy: ProductVariantOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductVariantConnection!
  node(id: ID!): Node
}

type Subscription {
  addressCustomer(where: AddressCustomerSubscriptionWhereInput): AddressCustomerSubscriptionPayload
  customer(where: CustomerSubscriptionWhereInput): CustomerSubscriptionPayload
  customerWishlist(where: CustomerWishlistSubscriptionWhereInput): CustomerWishlistSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productVariant(where: ProductVariantSubscriptionWhereInput): ProductVariantSubscriptionPayload
}

enum UniversalIdType {
  GTIN
  UPC
  EAN
}
`